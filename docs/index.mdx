---
title: "Superserve"
description: "Agent sandboxes with sessions, streaming, and zero-config deploys"
---

## The problem

You built an agent that works on your laptop. Now you need other people to use it.

With existing tools, that means: write a server, handle streaming, manage sessions, persist state between turns, set up sandboxed execution so the agent can safely run code, build a deploy pipeline, wire up secrets management. Weeks of infrastructure work before anyone can send your agent a message.

Sandbox platforms like E2B and Modal give you isolated compute — but you still build the API layer, session management, streaming, and deploy pipeline yourself. You're assembling infrastructure, not shipping an agent.

## The fix

```bash
pip install superserve
superserve deploy agent.py
```

That's it. Your agent is now a cloud API with:

- **Isolated sandboxes** — each session runs in its own [Firecracker microVM](https://firecracker-microvm.github.io/). Agents can execute code, write files, use tools — nothing escapes the sandbox.
- **Persistent workspace** — files survive across turns and restarts. Resume a conversation days later and the agent's workspace is exactly how it left it.
- **Multi-turn sessions** — built-in conversation state. No session management code, no database, no glue.
- **Real-time streaming** — responses stream back via SSE as they happen. No polling, no WebSocket plumbing.
- **Encrypted secrets** — API keys encrypted at rest, injected at runtime, never logged.
- **Sub-second cold starts** — pre-built sandbox templates start in ~400ms.

The same script that runs with `python agent.py` on your machine runs in the cloud. No Dockerfile, no server code, no infrastructure config.

```bash
$ superserve run my-agent "Review the error handling in src/auth.ts — are we leaking stack traces?"

Analyzing src/auth.ts and src/middleware/auth.ts...

Found 2 issues:
1. Line 47: `catch(e) { res.json({ error: e.message }) }`
   Leaks internal error details to clients. Return a generic 500 and
   log the full error server-side.
2. Line 82: Bare `catch {}` swallows errors silently.
   At minimum, log the error. Better: re-throw after logging.

The rest of the error handling looks correct — login() and refreshToken()
both use structured error responses.

Completed in 3.8s
```

---

## Works with any agent framework

Superserve runs your code as-is. No SDK lock-in, no framework requirements.

<CardGroup cols={3}>
  <Card title="Claude Agent SDK">
    ```bash
    superserve deploy agent.py
    ```
  </Card>
  <Card title="OpenAI Agents SDK">
    ```bash
    superserve deploy agent.py
    ```
  </Card>
  <Card title="Your own HTTP server">
    ```bash
    superserve deploy server.py --port 8000
    ```
  </Card>
</CardGroup>

Same command. Same infrastructure. Same streaming, sessions, and secrets.

---

<CardGroup cols={2}>
  <Card title="Quickstart" icon="bolt" href="/quickstart">
    Deploy an agent in 2 minutes
  </Card>
  <Card title="Zero-Config Deploy" icon="wand-magic-sparkles" href="/zero-config">
    How it works under the hood
  </Card>
  <Card title="SDK" icon="code" href="/sdk">
    TypeScript client, React hooks
  </Card>
  <Card title="CLI" icon="terminal" href="/cli">
    All commands and flags
  </Card>
</CardGroup>
